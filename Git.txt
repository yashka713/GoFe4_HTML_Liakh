С помощью GIT группа людей может работать над одним и тем же документом (чаще всего документ - это программный код) в одно и то же время не мешая друг-другу. Это и есть распределенная система контроля версий.

Ниже вы можете увидеть окошко терминала, вы находитесь в папке "octobox". Чтобы проинициализировать Git репозиторий введите команду: git init.
Отлично! Как только что нам сказал Git, наша папка "octobox" теперь обзавелась пустым репозиторием в /.git/. Репозиторий - это скрытая папка, в которой Git творит свою магию.

Следующее задание! Давайте попробуем набрать комнаду, выводяющую статус репозитория, чтобы увидеть в каком состоянии находится наш проект: git status

1.2 Проверяем статус
В вашем репозитории для вас создан файл с именем octocat.txt. Вы можете убедиться в этом, изучив содержимое папки в просмотрщике файлов под консолью.

Выполним команду статуса еще раз:git status; посмотрим как поменялся статус репозитория.

1.3 Добавляем файлы и коммитим
Хорошо. Похоже, что репозиторий работает правильно. Обратите внимание, что Git говорит octocat.txt является "неотслеживаемым"? Это означает, что Git видит, что octocat.txt является новым файлом.

Чтобы сообщить Git о том, что пора начать отслеживать изменения, внесенные в octocat.txt, мы сначала должны добавить его с помощью git add.

1.4 Добавление изменений
Продолжаем! Сейчас git отслеживает наш файл octocat.txt. Давайте выполним git status снова, чтобы понять, что изменилось!

1.5 Отслеживаение изменений
Вы обратили внимание, что Git говорит о возможности закоммитить изменения? Файлы, перечисленные здесь находятся в промежуточной области, пока что они не добавлены в наш репозиторий. Мы могли бы добавить или удалить файлы из этого состояния, прежде чем добавить их в хранилище.

Чтобы сохранить изменения на данном этапе мы выполним команду создания коммита и передадим ей в качестве аргумента сообщение, описывающие изменения, сделанные в этом коммите.
git commit -m "Add cute octocat story"
Отлично! Вы так же можете использовать шаблоны, если хотите добавить несколько файлов одного типа. Обратите внимание, что у нас появилось несколько файлов .txt в проекте.

Некоторые оказались в папке с именем "octofamily", а другие в корне проекта. К счастью, у нас есть возможность добавить все файлы, используя шаблон. Не забывайте про кавычки! 
git add '*.txt'

1.7 Добавляем все изменения
ОК! Вы добавили все текстовые файлы в промежуточную область. Не стесняйтесь еще раз выполнить git status, чтобы понять, что вы собираетесь закоммитить.

Выглядит неплохо, выполняем: 
git commit -m 'Add all the octocat txt files'

Отличная работа! Для вас создан новый пустой репозиторий на GitHub для работы с этим туториалом. Чтобы разместить наш локальный репозиторий на GitHub, мы должны добавить удаленный репозиторий. 
Эта команда принимает имя удаленного репозитория и его URL. В нашем случае это https://github.com/try-git/try_git.git

Выполняем команду с указанными аргументами: 
git remote add origin https://github.com/try-git/try_git.git

1.10 Удаленные репозиторииКоманда git push говорит Git, куда отправить наши изменения, когда все готово. Итак, запушим наши локальные изменения в наш удаленный репозиторий на GitHub. 
Имя удаленного репозитория origin, а ветка по умолчанию называется master(не думайте пока что о ветках!). Параметр -u позволит нам в будущем не указывать дополнительные параметры, а просто выполнять git push. Git будет знать, что нужно делать.

Сделаем это! 
git push -u origin master

1.11 Отпрвка изменений
Давайте представим, что прошло какое-то время. Мы пригласили других людей в наш проект, они забрали наши изменения в свои локальные репозитории и внесли свои изменения, запушили их. 
Мы можем проверить изменения на GitHub и спуллить их с помощью команды:

git pull origin master

1.12 Получение изменений
Ой! Похоже, кто-то еще вносил изменения в наш проект! Давайте посмотрим, что изменилось, с нашего последнего коммита, с помощью команды git diff. 
Мы можем проверить изменения на GitHub и спуллить их с помощью команды:

В данном случае мы хотим получить изменения с нашего последнего коммита, ссылку на который мы можем получить с помощью указателя HEAD. 
git diff HEAD

1.13 Различия
Еще один полезный вариант использования git diff - просмотр изменения, которые уже были помещены в промежуточную область. Запомните! В этой области находятся файлы, которые git готов(!) закоммитить. 
Мы можем проверить изменения на GitHub и спуллить их с помощью команды:

Давайте добавим новый файл octofamily/octodog.txt! 
git add octofamily/octodog.txt

1.14 Локальные различия
Отлично, теперь выполним предыдущую команду с флагом --staged. И увидим, какие изменения в нашем проекте мы собираемся коммитить. Вы должны увидеть, что файл octodog.txt создан.

git diff --staged

1.15 Локальные различия (продолжение)
Не стоило добавлять октособак к октокотам! Мы все-таки больше любим котиков. Удалим октопса из репозитория!

Вы можете удалять файлы из промежуточной области с помощью git reset. Сделаем это! 
git reset octofamily/octodog.txt

1.16 Отмена изменений
Безусловно, git проделал огромную работу по извлечению файла octodog.txt из промежуточной области. Но сам файл все еще находится в проекте! Было бы здорово, если бы мы могли вернуться к тому моменту, пока octodog не пришел и все не испортил.

Файлы могут быть возвращены в состояние последнего коммита с помощью команды: git checkout -- <target>. Откатим octocat.txt 
git checkout -- octocat.txt

1.17 Откатка изменений
Когда разработчики работают над новой фичей или багом, они обычно создают копию(или ветку) кода проекта, в которую они могут коммитить независимо. Когда разработка завершена, изменения из этой копии(ветки) нужно влить(вмержить) обратно в основную ветку проекта.

Мы решили удалить всех этих несчастных октокотиков, давайте создадим новую ветку и назовем ее clean_up 
git branch clean_up

1.18 Отбранчевываемся
Отлично! Сейчас, если вы выполните git branch, то увидите, что существует две ветки: master и clean_up.

Вы можете переключаться между ними с помощью команды git checkout <branch>. Попробуем! 
git checkout clean_up

1.19 Переключение веток
ОК, сейчас вы находитесь в ветке clean_up. Теперь можно удалять несчастных октокотиков с помощью команды git rm, которая не только удалит файлы с диска, но и добавит сведения об их удалении в Git.

Наверняка вы захотите воспользоваться шаблоном снова, чтобы сделать всю работу одним махом. Выполним: 
git rm '*.txt'

1.20 Удаление всего
После того, как вы удалили всех октокотиков, вам необходимо закоммитить ваши изменения.

Не забывапйте выполнить git status, чтобы проверить изменения перед коммитом. После этого смело выполняем уже известную нам команду: 
git commit -m "Remove all the cats"

1.21 Коммитим изменения в ветке
Отлично! Мы почти закончили с котиками... Т.е. с исправлением бага. Теперь вам необходимо вернуться в ветку master и скопировать (смержить) ваши изменения из ветки clean_up.

Возвращаемся в master 
git checkout master

1.22 Возвращаемся в master
Настал момент, когда вы должны смержить изменения из ветки clean_up в ветку master. Вдохните поглубже, это не так страшно!

Мы уже находимся в ветке master (вы уже знаете, как в этом убедиться). Осталось только сказать Git, что мы хотим смержить в текущую ветку другую - clean_up: 
git merge clean_up

1.23 Подготовка к слиянию
Поздравляем! Вы только что закончили свой первый самостоятельный багфикс и мерж. Все, что осталось сделать, - убрать за собой. После того как вы закончили работать с веткой clean_up, она вам больше не нужна.

Вы можете использовать команда git brnach -d <branch name> для удаления ветки. Сделаем это: 
git branch -d clean_up


1.24 Удаление ветки
Вот мы и на последнем шаге! Все, что нам осталось - залить (запушить) наши изменения в удаленный репозиторий на GitHub.

Вы уже знаете, что нужно делать: 
git push

1.25 Последний push

